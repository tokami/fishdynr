<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>times</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>





</head>

<body>
<p>#&#39; @title Virtual fish population
#&#39;
#&#39; @param K.mu mean K (growth parameter from von Bertalanffy growth function)
#&#39; @param K.cv coefficient of variation on K
#&#39; @param Linf.mu mean Linf (infinite length parameter from von Bertalanffy growth function)
#&#39; @param Linf.cv coefficient of variation on Linf
#&#39; @param t0 theoretical age at length 0
#&#39; @param ts summer point (range 0 to 1) (parameter from seasonally oscillating von Bertalanffy growth function)
#&#39; @param C strength of seasonal oscillation (range 0 to 1) (parameter from seasonally oscillating von Bertalanffy growth function)
#&#39; @param LWa length-weight relationship constant &#39;a&#39; (W = a*L<sup>b).</sup> Model assumed length in cm and weight in kg.
#&#39; @param LWb length-weight relationship constant &#39;b&#39; (W = a*L<sup>b).</sup> Model assumed length in cm and weight in kg.
#&#39; @param Lmat.f length at maturity for females (where 50\% of individuals are mature)
#&#39; @param wmat.f width between 25\% and 75\% quantiles for Lmat for females
#&#39; @param Lmat.m length at maturity for males(where 50\% of individuals are mature)
#&#39; @param wmat.m width between 25\% and 75\% quantiles for Lmat for males
#&#39; @param rmaxBH parameter for Beverton-Holt stock recruitment relationship (see \code{\link[fishdynr]{srrBH}})
#&#39; @param betaBH parameter for Beverton-Holt stock recruitment relationship (see \code{\link[fishdynr]{srrBH}})
#&#39; @param srr.cv coefficient of variation stock recruitment relationship
#&#39; @param repro_wt weight of reproduction (vector of monthly reproduction weight)
#&#39; @param M natural mortality
#&#39; @param Etf  effort (E = F / q); single numeric, numeric vector for effort per year, or matrix for different fleets (columns) and different years (rows)
#&#39; @param qtf catchability (default 0.005); single numeric, numeric vector for effort per year, or matrix for different fleets (columns)  and different years (rows)
#&#39; @param harvest_rate Fishing mortality (i.e. &#39;F&#39; = C/B); if NaN Etf and qtf are used to estimate the harvest_rate
#&#39; @param gear_types Character(s) defining the gear of the fishing fleet(s) (so far: either &ldquo;trawl&rdquo; or &ldquo;gillnet&rdquo;)
#&#39; @param L50 minimum length of capture (in cm). Where selectivity equals 0.5. Assumes logistic ogive typical of trawl net selectivity.
#&#39; @param wqs width of selectivity ogive (in cm)
#&#39; @param sel_list list with selectivities parameters for gillnet selectivity
#&#39; @param bin.size resulting bin size for length frequencies (in cm)
#&#39; @param timemin time at start of simulation (in years). Typically set to zero.
#&#39; @param timemax time at end of simulation (in years).
#&#39; @param timemin.date date corresponding to timemin (of &ldquo;Date&rdquo; class)
#&#39; @param tincr time increment for simulation (default = 1/12; i.e. 1 month)
#&#39; @param N0 starting number of individuals
#&#39; @param fished_t times when stock is fished; when NA no exploitation simulated
#&#39; @param lfqFrac fraction of fished stock that are sampled for length frequency data (default = 0.1).
#&#39; @param progressBar Logical. Should progress bar be shown in console (Default=TRUE)
#&#39; @param plot Logical. Should the standard plots be printed (Default=TRUE)
#&#39; @param seed integer; indicating the seed for set.seed()
#&#39;
#&#39; @description See \code{\link[fishdynr]{dt_growth_soVB}} for information on growth function.
#&#39; The model creates variation in growth based on a mean phi prime value for the population,
#&#39; which describes relationship between individual Linf and K values. See Vakily (1992)
#&#39; for more details.
#&#39;
#&#39; @details The model takes around 5 to 10 years to reach equilibrium, i.e. no biomass changes independent from fishing activity, the actual time is dependent on N0, K.mu, Lmat, repro_wt  and rmax.BH. For the estimation of carrying capacity the first 10 years of the simulation are disregarded and only subsequent years where no fishing took place are used to estimate the annual mean carrying capacity (K). If fishing is simulated for all years or fishing activities start before ten years after simulation start no carrying capacity is estimated.
#&#39;
#&#39; @return a list containing growth parameters and length frequency object
#&#39;
#&#39; @references
#&#39; Vakily, J.M., 1992. Determination and comparison of bivalve growth,
#&#39; with emphasis on Thailand and other tropical areas. WorldFish.
#&#39;
#&#39; Munro, J.L., Pauly, D., 1983. A simple method for comparing the growth
#&#39; of fishes and invertebrates. Fishbyte 1, 5-6.
#&#39;
#&#39; Pauly, D., Munro, J., 1984. Once more on the comparison of growth
#&#39; in fish and invertebrates. Fishbyte (Philippines).
#&#39;
#&#39; @importFrom graphics hist
#&#39; @importFrom stats rlnorm runif weighted.mean
#&#39; @importFrom utils txtProgressBar setTxtProgressBar
#&#39; @importFrom stats qnorm rnorm
#&#39; @importFrom TropFishR VBGF
#&#39;
#&#39; @export
#&#39;
#&#39; @examples
#&#39; \donttest{
#&#39; set.seed(1)
#&#39; res &lt;- virtualPop()
#&#39; names(res)
#&#39;
#&#39; op &lt;- par(mfcol=c(2,1), mar=c(4,4,1,1))
#&#39; plot(N ~ dates, data=res$pop, t=&ldquo;l&rdquo;)
#&#39; plot(B ~ dates, data=res$pop, t=&ldquo;l&rdquo;, ylab=&ldquo;B, SSB&rdquo;)
#&#39; lines(SSB ~ dates, data=res$pop, t=&ldquo;l&rdquo;, lty=2)
#&#39; par(op)
#&#39;
#&#39; pal &lt;- colorRampPalette(c(&ldquo;grey30&rdquo;,5,7,2), bias=2)
#&#39; with(res$lfqbin, image(x=dates, y=midLengths, z=t(catch), col=pal(100)))
#&#39;
#&#39; ### biased results with single monthly sample
#&#39; inds &lt;- res$inds[[1]]
#&#39; plot(mat ~ L, data = inds, pch=&ldquo;.&rdquo;, cex=5, col=rgb(0,0,0,0.05))
#&#39; fit &lt;- glm(mat ~ L, data = inds, family = binomial(link = &ldquo;logit&rdquo;))
#&#39; summary(fit)
#&#39;
#&#39; newdat &lt;- data.frame(L = seq(min(inds$L), max(inds$L), length.out=100))
#&#39; newdat$pmat &lt;- pmat_w(newdat$L, Lmat = 40, wmat=40*0.2)
#&#39; pred &lt;- predict(fit, newdata=newdat, se.fit=TRUE)
#&#39; # Combine the hypothetical data and predicted values
#&#39; newdat &lt;- cbind(newdat, pred)
#&#39; # Calculate confidence intervals
#&#39; std &lt;- qnorm(0.95 / 2 + 0.5)
#&#39; newdat$ymin &lt;- fit$family$linkinv(newdat$fit - std * newdat$se.fit)
#&#39; newdat$ymax &lt;- fit$family$linkinv(newdat$fit + std * newdat$se.fit)
#&#39; newdat$fit &lt;- fit$family$linkinv(newdat$fit)  # Rescale to 0-1
#&#39;
#&#39; plot(mat ~ L, data = inds, pch=&ldquo;.&rdquo;, cex=5, col=rgb(0,0,0,0.05))
#&#39; lines(pmat ~ L, newdat, col=8, lty=3)
#&#39; polygon(
#&#39;   x = c(newdat$L, rev(newdat$L)),
#&#39;   y = c(newdat$ymax, rev(newdat$ymin)),
#&#39;   col = adjustcolor(2, alpha.f = 0.3),
#&#39;   border = adjustcolor(2, alpha.f = 0.3)
#&#39; )
#&#39; lines(fit ~ L, newdat, col=2)
#&#39;
#&#39; lrPerc &lt;- function(alpha, beta, p) (log(p/(1-p))-alpha)/beta
#&#39; ( L50 &lt;- lrPerc(alpha=coef(fit)[1], beta=coef(fit)[2], p=0.5) )
#&#39; lines(x=c(L50,L50,0), y=c(-100,0.5,0.5), lty=2, col=2)
#&#39; text(x=L50, y=0.5, labels = paste0(&ldquo;L50 = &rdquo;, round(L50,2)), pos=4, col=2 )
#&#39;
#&#39;
#&#39;
#&#39; ### all samples combined
#&#39; inds &lt;- do.call(&ldquo;rbind&rdquo;, res$inds)
#&#39; plot(mat ~ L, data = inds, pch=&ldquo;.&rdquo;, cex=5, col=rgb(0,0,0,0.05))
#&#39; fit &lt;- glm(mat ~ L, data = inds, family = binomial(link = &ldquo;logit&rdquo;))
#&#39; summary(fit)
#&#39;
#&#39; newdat &lt;- data.frame(L = seq(min(inds$L), max(inds$L), length.out=100))
#&#39; newdat$pmat &lt;- pmat_w(newdat$L, Lmat = 40, wmat=40*0.2)
#&#39; pred &lt;- predict(fit, newdata=newdat, se.fit=TRUE)
#&#39; # Combine the hypothetical data and predicted values
#&#39; newdat &lt;- cbind(newdat, pred)
#&#39; # Calculate confidence intervals
#&#39; std &lt;- qnorm(0.95 / 2 + 0.5)
#&#39; newdat$ymin &lt;- fit$family$linkinv(newdat$fit - std * newdat$se.fit)
#&#39; newdat$ymax &lt;- fit$family$linkinv(newdat$fit + std * newdat$se.fit)
#&#39; newdat$fit &lt;- fit$family$linkinv(newdat$fit)  # Rescale to 0-1
#&#39;
#&#39; plot(mat ~ L, data = inds, pch=&ldquo;.&rdquo;, cex=5, col=rgb(0,0,0,0.05))
#&#39; lines(pmat ~ L, newdat, col=8, lty=3)
#&#39; polygon(
#&#39;   x = c(newdat$L, rev(newdat$L)),
#&#39;   y = c(newdat$ymax, rev(newdat$ymin)),
#&#39;   col = adjustcolor(2, alpha.f = 0.3),
#&#39;   border = adjustcolor(2, alpha.f = 0.3)
#&#39; )
#&#39; lines(fit ~ L, newdat, col=2)
#&#39;
#&#39; lrPerc &lt;- function(alpha, beta, p) (log(p/(1-p))-alpha)/beta
#&#39; ( L50 &lt;- lrPerc(alpha=coef(fit)[1], beta=coef(fit)[2], p=0.5) )
#&#39; lines(x=c(L50,L50,0), y=c(-100,0.5,0.5), lty=2, col=2)
#&#39; text(x=L50, y=0.5, labels = paste0(&ldquo;L50 = &rdquo;, round(L50,2)), pos=4, col=2 )
#&#39;
#&#39;
#&#39; }
#&#39;
#&#39;</p>

<p>virtualPop &lt;- function(
tincr = 1/12,
K.mu = 0.5, K.cv = 0.1,
Linf.mu = 80, Linf.cv = 0.1,
t0 = -0.03,
ts = 0, C = 0.85,
LWa = 0.01, LWb = 3,
Lmat.f = 0.5*Linf.mu, wmat.f = Lmat.f*0.2,
Lmat.m = 0.45*Linf.mu, wmat.m = Lmat.m*0.15,
rmaxBH = 1000,
betaBH = 1, srr.cv = 0.1,
repro_wt = c(0,0,0,1,0,0,0,0,0,0,0,0),
M = 0.7,
Etf = 500,
qtf = 0.001,
harvest_rate = NaN,
gear_types = &ldquo;trawl&rdquo;,   # alternative: &ldquo;gillnet&rdquo;
L50 = 0.25*Linf.mu,
wqs = L50*0.2,
sel_list = list(mesh_size=100, mesh_size1=60,select_dist=&ldquo;lognormal&rdquo;,select_p1=3, select_p2=0.5),  # parameters adapted from the tilapia data set (increased spread)
bin.size = 1,
timemin = 0, timemax = 25, timemin.date = as.Date(&ldquo;1980-01-01&rdquo;),
N0 = 1000,
fished_t = seq(17,25,tincr),
lfqFrac = 1,
progressBar = TRUE,
plot = TRUE,
seed = NULL
){</p>

<p>## Fishing mortality - effort - catchability
  ## if E == single value, assuming one fleet and same effort for all fished years
  if(length(as.numeric(Etf))==1){
    Emat &lt;- as.matrix(rep(Etf,length(fished_t)))
  }
  ## if E == matrix, rows = years and columns = fleets</p>

<pre><code>if(class(Etf) == &quot;matrix&quot;){
  Emat &lt;- Etf
}else if(length(Etf)&gt;1){
  Emat &lt;- as.matrix(Etf)
}

## adapt q to Emat
if(length(qtf)==1){
    qmat &lt;- matrix(qtf, ncol=dim(Emat)[2], nrow=dim(Emat)[1])
}
if(class(qtf) == &quot;matrix&quot;){
    if(dim(qtf)[1] != dim(Emat)[1]){
        qmat &lt;- matrix(rep(qtf[1,], dim(Emat)[1]),ncol=dim(qtf)[2],byrow=TRUE) # qft -&gt; qtf?
    }else{
        qmat &lt;- qtf
    }
}else if(length(qtf)&gt;1){
    qmat &lt;- as.matrix(qtf)
}
</code></pre>

<p>## If no harvest_rate provided assuming that effort * catchability = fishing mortality
  if(!is.na(harvest_rate) &amp; !is.nan(harvest_rate)){
    if(length(as.numeric(harvest_rate))==1){
      harvest_rate &lt;- rep(harvest_rate, length(fished_t))
    }else{
      harvest_rate &lt;- matrix(rep(harvest_rate, each = length(fished_t)), 
                             ncol = length(harvest_rate), nrow = length(fished=fished_t))
    }
    }else{
      harvest_rate &lt;- Emat * qmat
    }</p>

<pre><code>selfunc &lt;- function(Lt, fleetNo){
    if(is.na(fleetNo)){
        gear_typesX &lt;- gear_types
        L50X &lt;- L50
        wqsX &lt;- wqs
        sel_listX &lt;- sel_list
    }else{
        gear_typesX &lt;- gear_types[fleetNo]
    }
    switch(gear_typesX,
           trawl ={
               if(!is.na(fleetNo)){
                   L50X &lt;- L50[fleetNo]
                   wqsX &lt;- wqs[fleetNo]
               }
               pSel &lt;- logisticSelect(Lt=Lt, L50=L50X, wqs=wqsX)},
           gillnet={
               if(!is.na(fleetNo)){
                   sel_listX &lt;- sel_list[[fleet_No]]
               }
               pSel &lt;- do.call(fishdynr::gillnet, c(list(Lt=Lt),sel_listX))
           },
           stop(paste(&quot;\n&quot;,gear_typesX,&quot;not recognized, possible options are: \n&quot;,&quot;trawl \n&quot;,&quot;gillnet \n&quot;)))
    return(pSel)
}

## ## if multiple fleets target the same stock, the harvest rate of each fleet is scaled according to the combined harvest rate - this only works if all fleets would have the same gear!
## if(class(harvest_rate) == &quot;matrix&quot;){
##     multimat &lt;- harvest_rate / rowSums(harvest_rate)
##     harvest_rate &lt;- rowSums(harvest_rate * multimat)
##    }
</code></pre>

<h1>times</h1>

<p>timeseq = seq(from=timemin, to=timemax, by=tincr)
if(!zapsmall(1/tincr) == length(repro_wt)) stop(&ldquo;length of repro_wt must equal the number of tincr in one year&rdquo;)
repro_wt &lt;- repro_wt/sum(repro_wt)
repro_t &lt;- rep(repro_wt, length=length(timeseq))</p>

<h1>repro_t &lt;- seq(timemin+repro_toy, timemax+repro_toy, by=1)</h1>

<h1>make empty lfq object</h1>

<p>lfq &lt;- vector(mode=&ldquo;list&rdquo;, length(timeseq))
names(lfq) &lt;- timeseq</p>

<p>indsSamp &lt;- vector(mode=&ldquo;list&rdquo;, length(timeseq))
names(indsSamp) &lt;- timeseq</p>

<h1>Estimate tmaxrecr</h1>

<p>tmaxrecr &lt;- (which.max(repro_wt)-1)*tincr</p>

<h1>mean phiprime</h1>

<p>phiprime.mu = log10(K.mu) + 2*log10(Linf.mu)</p>

<h1>required functions &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<p>date2yeardec &lt;- function(date){as.POSIXlt(date)$year+1900 + (as.POSIXlt(date)$yday)/365}
yeardec2date &lt;- function(yeardec){as.Date(strptime(paste(yeardec%/%1, ceiling(yeardec%%1*365+1), sep=&ldquo;-&rdquo;), format=&ldquo;%Y-%j&rdquo;))}</p>

<p>make.inds &lt;- function(
    id=NaN, A = 0, L = 0, W=NaN, sex = NaN, mat=0,
    K = K.mu, Winf=NaN, Linf=NaN, phiprime=NaN,
    F=NaN, Z=NaN, Fd=0, alive=1
){
  inds &lt;- data.frame(
    id = id,
    A = A,
    L = L,
    W = W,
    sex = sex,
    Lmat=NaN,
    mat = mat,
    K = K,
    Linf = Linf,
    Winf = Winf,
    phiprime = phiprime,
    F = F,
    Z = Z,
    Fd = Fd,
    alive = alive
  )
  lastID &lt;&lt;- max(inds$id)
  return(inds)
}</p>

<p>express.inds &lt;- function(inds, seed){
  set.seed(seed)
  inds$Linf &lt;- Linf.mu * rlnorm(nrow(inds), 0, Linf.cv)
  inds$Winf &lt;- LWa*inds$Linf<sup>LWb</sup>
  # inds$K &lt;- 10<sup>phiprime.mu - 2*log10(inds$Linf</sup>) * rlnorm(nrow(inds), 0, K.cv)
  seed1 &lt;- seed + 1
  set.seed(seed1)
  inds$K &lt;- K.mu * rlnorm(nrow(inds), 0, K.cv)
  inds$W &lt;- LWa*inds$L<sup>LWb</sup>
  inds$phiprime &lt;- log10(inds$K) + 2*log10(inds$Linf)
  seed2 &lt;- seed + 2
  set.seed(seed2)
  inds$sex &lt;- rbinom(nrow(inds), size = 1, prob = .5)  # 0 = F, 1 = M
  seed3 &lt;- seed + 3
  set.seed(seed3)
  inds$Lmat[which(inds$sex == 0)] &lt;- rnorm(length(which(inds$sex == 0)), mean=Lmat.f, sd=wmat.f/diff(qnorm(c(0.25, 0.75))))
  seed4 &lt;- seed + 4
  set.seed(seed4)
  inds$Lmat[which(inds$sex == 1)] &lt;- rnorm(length(which(inds$sex == 1)), mean=Lmat.m, sd=wmat.m/diff(qnorm(c(0.25, 0.75))))
  inds$L &lt;- dt_growth_soVB(Linf = inds$Linf, K = inds$K, ts = ts, C = C, L1 = 0, t1 = t0, t2 = 0)
    return(inds)
}</p>

<p>grow.inds &lt;- function(inds){
    # grow
  L2 &lt;- dt_growth_soVB(Linf = inds$Linf, K = inds$K, ts = ts, C = C, L1 = inds$L, t1 = tj-tincr, t2 = tj)
  # update length and weight
    inds$L &lt;- L2
    inds$W &lt;- LWa*inds$L<sup>LWb</sup>
    # age inds
    inds$A &lt;- inds$A + tincr
    return(inds)
}</p>

<p>mature.inds &lt;- function(inds){
    # p &lt;- pmat_w(inds$L, Lmat, wmat) # probability of being mature at length L
    # p1t &lt;- 1-((1-p)<sup>tincr)</sup>
    # inds$mat &lt;- ifelse(runif(nrow(inds)) &lt; p1t | inds$mat == 1, 1, 0)
  inds$mat &lt;- ifelse((inds$L &gt; inds$Lmat | inds$mat == 1), 1, 0)
    return(inds)
}</p>

<p>reproduce.inds &lt;- function(inds, seed, save = FALSE){
    ## reproduction can only occur of population contains &gt;1 mature individual
    if(repro &gt; 0 &amp; sum(inds$mat) &gt; 0){
        ## calc. SSB
        SSB &lt;- sum(inds$W*inds$mat)
        n.recruits &lt;- ceiling(srrBH(rmaxBH, betaBH, SSB) * repro)
        ## add noise to recruitment process
        seed5 &lt;- seed + 5
        set.seed(seed5)
        n.recruits &lt;- n.recruits * rlnorm(1, 0, sdlog = srr.cv)
        ## save SSB + n.recruits for stock recruitment plot
        if(save) stockRec &lt;&lt;- rbind(stockRec, data.frame(SSB = SSB, recruits = n.recruits))
        ## make recruits
        offspring &lt;- make.inds(
            id = seq(lastID+1, length.out=n.recruits)
        )
        ## express genes in recruits
        offspring &lt;- express.inds(offspring, seed = seed+10)
        ##combine all individuals
        inds &lt;- rbind(inds, offspring)
    }
    return(inds)
}</p>

<p>death.inds &lt;- function(inds, seed, f0 = FALSE){
  ## multiple fleets
  if(class(harvest_rate)==&ldquo;matrix&rdquo;){
    if(dim(harvest_rate)[2]&gt;=2){
      pSel &lt;- matrix(NaN, ncol=dim(harvest_rate)[2],nrow=dim(inds)[1])
      for(seli in 1:(dim(harvest_rate)[2])){
        pSel[,seli] &lt;- selfunc(Lt = inds$L, fleetNo = seli)
      }
      ## effective fishing mortality (in relation to selectivity) - per fleet with mutliple fleets
      Feff &lt;- pSel * Fmax
      ## single fishing mortality value (per year) scaled according to F of each fleet
      ## this calculation only works if there is fishery (Fmax in denominator not allowed to be 0, otherwise F = NaN and then Z = NaN), thus:
      if(all(Fmax == 0)){
        inds$F &lt;- 0
      }else{
        inds$F &lt;- as.numeric(rowSums(Feff * Fmax) / sum(Fmax))
      }
    }else{
      ## single fleet
      pSel &lt;- selfunc(Lt = inds$L, fleetNo = NA)
      inds$F &lt;- as.numeric(pSel * Fmax)
    }
  }else{
    ## single fleet
    pSel &lt;- selfunc(Lt = inds$L, fleetNo = NA)
    inds$F &lt;- as.numeric(pSel * Fmax)
  }
  inds$Z &lt;- M + inds$F
  if(f0) inds$Z &lt;- M
  pDeath &lt;- 1 - exp(-inds$Z*tincr)
  seed6 &lt;- seed + 6
  set.seed(seed6)
  dead &lt;- which(runif(nrow(inds)) &lt; pDeath)
  # determine if natural or fished
  if(length(dead) &gt; 0){
    inds$alive[dead] &lt;- 0
    tmp &lt;- cbind(inds$F[dead], inds$Z[dead])
    # Fd=1 for fished individuals; Fd=0, for those that died naturally
    seed7 &lt;- seed + 7
    set.seed(seed7)
    Fd &lt;- apply(tmp, 1, FUN=function(x){sample(c(0,1), size=1, prob=c(M/x[2], x[1]/x[2]) )})
    inds$Fd[dead] &lt;- Fd
    rm(tmp)
  }
  return(inds)
}</p>

<p>remove.inds &lt;- function(inds){
  dead &lt;- which(inds$alive == 0)
  if(length(dead)&gt;0) {inds &lt;- inds[-dead,]}
  return(inds)
}</p>

<p>record.inds &lt;- function(inds, ids=1:10, rec=NULL){
    if(is.null(rec)) {
        rec &lt;- vector(mode=&ldquo;list&rdquo;, length(ids))
        names(rec) &lt;- ids
        inds &lt;- inds
    } else {
        ids &lt;- as.numeric(names(rec))
    }
    if(length(rec) &gt; 0) {
        inds.rows.rec &lt;- which(!is.na(match(inds$id, ids)))
        if(length(inds.rows.rec) &gt; 0){
            for(ii in inds.rows.rec){
                match.id &lt;- match(inds$id[ii], ids)
                if(is.null(rec[[match.id]])) {
                    rec[[match.id]] &lt;- inds[ii,]
                } else {
                    rec[[match.id]] &lt;- rbind(rec[[match.id]], inds[ii,])
                }
            }
        }
    }
    return(rec)
}</p>

<p>spmOpt &lt;- function(x, B0){
  K = x[1]
  r = x[2]
  n = x[3]
  Bthat &lt;- rep(NA, length(resf0$pop$B))
  Bthat[1] &lt;- B0
  for(i in 2:length(Bthat)){
    Bthat[i] &lt;- Bthat[i-1] + ((r / (n - 1)) * Bthat[i-1] * (1 - (Bthat[i-1] / K)<sup>n-1</sup>))*tincr
  }
  sum((resf0$pop$B - Bthat)<sup>2)</sup>
}</p>

<p>spmPlot &lt;- function(pars){
  B0 &lt;- pars[1]
  K &lt;- pars[2]
  r &lt;- pars[3]
  n &lt;- pars[4]
  Bthat &lt;- rep(NA, length(resf0$pop$B))
  Bthat[1] &lt;- B0
  for(i in 2:length(Bthat)){
    Bthat[i] &lt;- Bthat[i-1] + ((r / (n - 1)) * Bthat[i-1] * (1 - (Bthat[i-1] / K)<sup>n-1</sup>))*tincr
  }
  Bthat
}</p>

<pre><code>## run model ---------------------------------------------------------------

## seed values
if(is.null(seed) || is.null(seed)){
    seed &lt;- floor(runif(1,1,1000))
}
seed2 &lt;- seed + floor(runif(1,1,100))
</code></pre>

<h1>Initial population</h1>

<p>lastID &lt;- 0
inds &lt;- make.inds(
  id=seq(N0)
)
inds &lt;- express.inds(inds = inds, seed = seed)</p>

<h2>results object</h2>

<p>res &lt;- list()
res$pop &lt;- list(
  dates = yeardec2date( date2yeardec(timemin.date) + (timeseq - timemin) ),
    N = NaN*timeseq,
    B = NaN*timeseq,
    SSB = NaN*timeseq
)</p>

<p>stockRec &lt;- as.data.frame(matrix(ncol=2,nrow=0))
colnames(stockRec) &lt;- c(&ldquo;SSB&rdquo;, &ldquo;recruits&rdquo;)</p>

<h2>For simulation of unfished population</h2>

<h2>Initial population</h2>

<p>lastID &lt;- 0
indsf0 &lt;- make.inds(
  id=seq(N0)
)
indsf0 &lt;- express.inds(inds = indsf0, seed = seed)</p>

<h2>results object</h2>

<p>resf0 &lt;- list()
resf0$pop &lt;- list(
  dates = yeardec2date(date2yeardec(timemin.date) + (timeseq - timemin)),
  N = NaN*timeseq,
  B = NaN*timeseq,
  SSB = NaN*timeseq
)</p>

<h2>simulation</h2>

<p>if(progressBar) pb &lt;- txtProgressBar(min=1, max=length(timeseq), style=3)
for(j in seq(timeseq)){
  tj &lt;- timeseq[j]</p>

<p>## harvest rate applied? lfq sampled?
  if(is.na(fished_t[1]) | is.nan(fished_t[1])){ ## before: length(fished_t) == 0 : as I see it fished_t never has length 0, even if set ot NA or NaN, it woudl have length 1
    Fmax &lt;- 0
    lfqSamp &lt;- 0
  } else if(min(sqrt((tj-fished_t)<sup>2))</sup> &lt; 1e-8){
       ## time index for fished_t
          tfish &lt;- which.min(abs(fished_t - tj))
          ## provide yearly Fmax value (per fleet if multiple fleets simulated)
          if(class(harvest_rate) == &ldquo;matrix&rdquo;){
              Fmax &lt;- harvest_rate[tfish,]
          }else if(length(harvest_rate)&gt;1){
             Fmax &lt;- harvest_rate[tfish]
          }else{
              Fmax &lt;- harvest_rate
          }
          lfqSamp &lt;- 1
          } else {
      Fmax &lt;- 0
      lfqSamp &lt;- 0
    }</p>

<p>repro &lt;- repro_t[j]</p>

<pre><code># population processes
inds &lt;- grow.inds(inds)
inds &lt;- mature.inds(inds)
inds &lt;- reproduce.inds(inds = inds, seed = seed+11+j)
inds &lt;- death.inds(inds, seed = seed2+j)
## sample lfq data
if(lfqSamp){
  samp &lt;- try(sample(seq(inds$L), ceiling(sum(inds$Fd)*lfqFrac), prob = inds$Fd), silent = TRUE)
if(class(samp) != &quot;try-error&quot;){
  lfq[[j]] &lt;- inds$L[samp]
  indsSamp[[j]] &lt;- inds[samp,]
}
rm(samp)
</code></pre>

<p>}
    inds &lt;- remove.inds(inds)</p>

<pre><code># update results
res$pop$N[j] &lt;- nrow(inds)
res$pop$B[j] &lt;- sum(inds$W)
res$pop$SSB[j] &lt;- sum(inds$W*inds$mat)

## simulate unfished population for K, r and SSB_F=0
# population processes
indsf0 &lt;- grow.inds(indsf0)
indsf0 &lt;- mature.inds(indsf0)
indsf0 &lt;- reproduce.inds(inds = indsf0, seed = seed+11+j, save = TRUE)
indsf0 &lt;- death.inds(indsf0, seed = seed2+j, f0 = TRUE)
indsf0 &lt;- remove.inds(indsf0)

# update results
resf0$pop$N[j] &lt;- nrow(indsf0)
resf0$pop$B[j] &lt;- sum(indsf0$W)
resf0$pop$SSB[j] &lt;- sum(indsf0$W * indsf0$mat)

## update progressbar
if(progressBar) setTxtProgressBar(pb, j)
</code></pre>

<p>}
if(progressBar) close(pb)</p>

<h2>Estimate carrying capacity</h2>

<h2>Alternative way build into loop above</h2>

<p>startyear  &lt;- as.POSIXlt(timemin.date)
startyear$year &lt;- startyear$year + 20
year10 &lt;- as.Date(startyear)
cutoff &lt;- which.min(abs(yeardec2date( date2yeardec(timemin.date) + (timeseq - timemin)) - year10))
cc_years &lt;- seq(timeseq)[-(1:cutoff)]
if(length(cc_years) &gt; 3){
      mod &lt;- lm(resf0$pop$B[cc_years] ~ 1)
      resf0$pop$K &lt;- as.numeric(coefficients(mod))
}
if(length(cc_years) &gt; 3){
  mod &lt;- lm(resf0$pop$SSB[cc_years] ~ 1)
  resf0$pop$SSBf0 &lt;- as.numeric(coefficients(mod))
}
if(length(cc_years) &gt; 3){
  mod &lt;- lm(res$pop$SSB[cc_years] ~ 1)
  res$pop$SSBf &lt;- as.numeric(coefficients(mod))
}</p>

<h2>estimate K, r, n</h2>

<p>resSPM &lt;- optim(par = c(resf0$pop$K, 1, 2), fn = spmOpt, B0 = resf0$pop$B[1])
Kest &lt;- resSPM$par[1]
rest &lt;- resSPM$par[2]
nest &lt;- resSPM$par[3]
gammal &lt;- nest<sup>nest/(nest-1</sup>)/(nest-1)
m &lt;- rest * Kest / (nest<sup>nest/(nest-1</sup>))</p>

<h2>Deterministic reference levels</h2>

<p>if(nest == 1){
  ## Fox reference levels
  Bdmsy &lt;- Kest/exp(1)
  msyd &lt;- rest * Kest / exp(1)
  Fdmsy &lt;- rest
}else{
  ## Pella and Tomlinson reference levels
  Bdmsy &lt;- nest<sup>1/(1-nest</sup>) * Kest
  msyd &lt;- m
  Fdmsy &lt;- m/Bdmsy
}</p>

<h2>save parameters</h2>

<p>resf0$pop$K2 &lt;- Kest
resf0$pop$r &lt;- rest
resf0$pop$n &lt;- nest
resf0$pop$m &lt;- m
resf0$pop$gamma &lt;- gammal</p>

<h1>Export data &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</h1>

<pre><code>## for simulation of population without exploitation, necessary to make the lfq export optional:
if(any(!is.na(fished_t[1]) &amp; !is.nan(fished_t[1])) &amp; (lfqFrac != 0 &amp; !is.na(lfqFrac) &amp; !is.nan(lfqFrac))){
    ## Trim and Export &#39;lfq&#39;
    lfq2 &lt;- lfq[which(sapply(lfq, length) &gt; 0)]
    ## binned version of lfq
    dates &lt;- yeardec2date( date2yeardec(timemin.date) + (as.numeric(names(lfq2)) - timemin) )
    Lran &lt;- range(unlist(lfq2))
    Lran[1] &lt;- floor(Lran[1])
    Lran[2] &lt;- (ceiling(Lran[2])%/%bin.size + ceiling(Lran[2])%%bin.size + 1) * bin.size
    bin.breaks &lt;- seq(Lran[1], Lran[2], by=bin.size)
    bin.mids &lt;- bin.breaks[-length(bin.breaks)] + bin.size/2
    res$lfqbin &lt;- list(
        sample.no = seq(bin.mids),
        midLengths = bin.mids,
        dates = dates,
        catch = sapply(lfq2, FUN = function(x){
            hist(x, breaks=bin.breaks, plot = FALSE, include.lowest = TRUE)$counts
        })
    )
}
</code></pre>

<h2>Saving reference levels</h2>

<p>fished_dates &lt;- res$lfqbin$dates ## yeardec2date(date2yeardec(timemin.date) + (fished_t - timemin))</p>

<h2>fished_index &lt;- seq(fished_t[1],fished_t[length(fished_t)],1)</h2>

<p>fished_years &lt;- unique(format(fished_dates, &ldquo;%Y&rdquo;)) ## format(yeardec2date(date2yeardec(timemin.date) + (fished_index - timemin)),&ldquo;%Y&rdquo;)
res$refLev &lt;- list()
temp1 &lt;- aggregate(res$pop$SSB, 
                   by = list(years = format(res$pop$dates, &ldquo;%Y&rdquo;)), 
                   FUN = mean, na.rm=TRUE) 
temp2 &lt;- aggregate(resf0$pop$SSB, 
                   by = list(years = format(res$pop$dates, &ldquo;%Y&rdquo;)), 
                   FUN = mean, na.rm=TRUE) </p>

<h2>SPR</h2>

<p>res$refLev$years &lt;- fished_years
res$refLev$SPR &lt;- temp1$x[temp1$years %in% as.numeric(fished_years)] / 
  temp2$x[temp1$years %in% as.numeric(fished_years)] </p>

<h2>SPM refs</h2>

<p>res$refLev$Bdmsy &lt;- Bdmsy
res$refLev$msyd &lt;- msyd
res$refLev$Fdmsy &lt;- Fdmsy</p>

<h2>yearly harvest rate and biomass</h2>

<p>temp &lt;- aggregate(list(bio = res$pop$B), by=list(years = format(res$pop$dates,&ldquo;%Y&rdquo;)), mean, na.rm=TRUE)
bioYear &lt;- temp$bio[temp$years %in% as.numeric(fished_years)]
if(any(!is.na(as.numeric(harvest_rate)))){
  temp &lt;- aggregate(list(x = as.numeric(harvest_rate)), 
                    by=list(year = floor(fished_t)), mean, na.rm=TRUE)
  harvest_rateYear &lt;- temp$x
}
temp &lt;- unique(format(yeardec2date(date2yeardec(timemin.date) + (fished_t - timemin)),&ldquo;%Y&rdquo;))
harvest_rateYear &lt;- harvest_rateYear[temp %in% fished_years]</p>

<h2>Production curve</h2>

<p>bioPlot &lt;- spmPlot(c(res$pop$B[1], Kest,  rest, nest))
Prod &lt;- (rest / (nest - 1)) * bioPlot * (1 - (bioPlot / Kest)<sup>nest-1</sup>)</p>

<h2>LBIs</h2>

<h2>aggregate lfq data per year</h2>

<p>c_sum &lt;- with(res$lfqbin,by(t(catch), format(dates, &ldquo;%Y&rdquo;), FUN = colSums))
c_list &lt;- lapply(as.list(c_sum), c)
midLengths &lt;- res$lfqbin$midLengths
dates &lt;- unique(as.Date(paste0(format(dates, &ldquo;%Y&rdquo;), &ldquo;-01-01&rdquo;)))</p>

<h2>cumulative and percentage cumulative catches</h2>

<p>cumSum &lt;- lapply(c_list, cumsum)
cumSum_perc &lt;- vector(&ldquo;list&rdquo;,length(dates))
for(i in 1:length(c_list)){
  cumSum_perc[[i]] &lt;- cumSum[[i]] / sum(c_list[[i]])
}</p>

<h2>mean length of largest 5% (/Linf &gt;.8)</h2>

<p>numb &lt;- lapply(c_list, function(x) x[rev(order(midLengths))])    # from largest starting
midLengthsRev &lt;- midLengths[rev(order(midLengths))]
Lmax5 &lt;- vector(&#39;numeric&#39;,length(dates))
for(i in 1:length(dates)){
  numbcum &lt;- cumsum(numb[[i]]) 
  numbcumperc &lt;- round(numbcum / sum(numb[[i]]),5)
  numbnum5 &lt;- rep(0, length(numbcumperc))
  numbnum5[numbcumperc &lt;= 0.05] &lt;- numb[[i]][numbcumperc &lt;= 0.05]
  numbnum5[max(which(numbcumperc &lt;= 0.05),na.rm = TRUE) + 1] &lt;- (0.05 - numbcumperc[max(which(numbcumperc &lt;= 0.05),na.rm = TRUE)]) * sum(numb[[i]])
  Lmax5[i] &lt;- sum(numbnum5 * midLengthsRev, na.rm = TRUE) / sum(numbnum5, na.rm = TRUE)
}
res$refLev$Lmax5 &lt;- round(Lmax5,2)</p>

<h2>95th percentile (/Linf &gt;.8)</h2>

<p>L95 &lt;- unlist(lapply(cumSum_perc, function(x) min(midLengths[which(x &gt;= 0.95)],na.rm=TRUE)))
res$refLev$L95 &lt;- L95</p>

<h2>Pmega (Lopt + 10%) (&gt;.3)</h2>

<p>Lopt &lt;- (2 / 3) * Linf.mu
Pmega &lt;- vector(&#39;numeric&#39;, length(dates))
for(i in 1:length(dates)){
  Pmega[i] &lt;- sum(c_list[[i]][which(midLengths &gt;= (Lopt + 0.1 * Lopt))], na.rm = TRUE) / 
    sum(c_list[[i]], na.rm = TRUE)
}
res$refLev$Pmega &lt;- Pmega
res$refLev$Lopt &lt;- Lopt</p>

<h2>25th percentile of length distribution (/Lmat &gt;1)</h2>

<p>L25 &lt;- unlist(lapply(cumSum_perc, function(x) min(midLengths[which(x &gt;= 0.25)],na.rm=TRUE)))
res$refLev$L25 &lt;- L25
Lmat &lt;- mean(c(Lmat.f,Lmat.m))</p>

<h2>Lc (/Lmat &gt;1)  ICES: Lc (Length at first catch = 50% of mode)</h2>

<p>Lc &lt;- L50   ## check again with gillnet selectivity, then ICES formula
res$refLev$Lc &lt;- Lc</p>

<h2>alternatively: 50% of mode</h2>

<p>modes &lt;- unlist(lapply(c_list, function(x) midLengths[x == max(x, na.rm=TRUE)]))
Lcalt &lt;- vector(&#39;numeric&#39;,length(dates))
for(i in 1:length(dates)){
  temp &lt;- as.numeric(cumSum_perc[[i]][modes[i]])
  Lcalt[i] &lt;- midLengths[which.min(abs(cumSum_perc[[i]] - 0.5 * temp))]
}
res$refLev$Lc.alt &lt;- Lcalt</p>

<h2>mean length of individuals &gt; Lc (/Lopt ~1 ; /LF=M &gt;= 1)</h2>

<p>c_listLC &lt;- lapply(c_list, function(x) x[midLengths &gt;= Lc])
midLengthsLC &lt;- midLengths[midLengths &gt;= Lc]
Lmean &lt;- vector(&#39;numeric&#39;, length(dates))
for(i in 1:length(c_listLC)){
  Lmean[i] &lt;- sum(midLengthsLC * c_listLC[[i]], na.rm = TRUE) / sum(c_listLC[[i]], na.rm = TRUE)
}
LFeM &lt;- 0.75 * Lc + 0.25 * Linf.mu
res$refLev$Lmean &lt;- round(Lmean,2)
res$refLev$LFeM &lt;- LFeM</p>

<h2>length class with maximum in biomass (/Lopt ~1)</h2>

<p>midWeights &lt;- LWa * midLengths ^ LWb
bio_list &lt;- lapply(c_list, function(x) x * midWeights)
Lmaxy &lt;- unlist(lapply(bio_list, function(x) midLengths[x == max(x, na.rm = TRUE)]))
res$refLev$Lmaxy &lt;- as.numeric(Lmaxy)</p>

<p>res$refLev$states &lt;- data.frame(&ldquo;Lmax5/Linf&rdquo; = round(Lmax5/Linf.mu,2),
                                &ldquo;L95/Linf&rdquo; = round(L95/Linf.mu,2),
                                &ldquo;Pmega&rdquo; = round(Pmega,2),
                                &ldquo;L25/Lmat&rdquo; = round(L25/Lmat,2),
                                &ldquo;Lc/Lmat&rdquo; = round(Lcalt/Lmat,2),
                                &ldquo;Lmean/Lopt&rdquo; = round(Lmean/Lopt,2),
                                &ldquo;Lmaxy/Lopt&rdquo; = round(Lmaxy/Lopt,2),
                                &ldquo;Lmean/LFeM&rdquo; = round(Lmean/LFeM,2),
                                &ldquo;SPR&rdquo; = round(res$refLev$SPR,2),
                                &ldquo;F/Fmsy&rdquo; = round(harvest_rateYear/Fdmsy,2),
                                &ldquo;B/Bmsy&rdquo; = round(bioYear/Bdmsy,2))
res$refLev$statesRefPoint &lt;- data.frame(&ldquo;Lmax5/Linf&rdquo; = &ldquo;&gt;0.8&rdquo;,
                                        &ldquo;L95/Linf&rdquo; = &ldquo;&gt;0.8&rdquo;,
                                        &ldquo;Pmega&rdquo; = &ldquo;&gt;0.3&rdquo;,
                                        &ldquo;L25/Lmat&rdquo; = &ldquo;&gt;1&rdquo;,
                                        &ldquo;Lc/Lmat&rdquo; = &ldquo;&gt;1&rdquo;,
                                        &ldquo;Lmean/Lopt&rdquo; = &ldquo;=1&rdquo;,
                                        &ldquo;Lmaxy/Lopt&rdquo; = &ldquo;=1&rdquo;,
                                        &ldquo;Lmean/LFeM&rdquo; = &ldquo;&gt;=1&rdquo;,
                                        &ldquo;SPR&rdquo; = &ldquo;&gt;0.3&rdquo;,
                                        &ldquo;F/Fmsy&rdquo; = &ldquo;&lt;=1&rdquo;,
                                        &ldquo;B/Bmsy&rdquo; = &ldquo;&gt;=1&rdquo;)</p>

<h2>estimate LBIs again specific for males and females</h2>

<h1>individuals</h1>

<p>indsSamp &lt;- indsSamp[which(sapply(indsSamp, length) &gt; 0)]
res$inds &lt;- indsSamp</p>

<h1>record mean parameters</h1>

<p>res$growthpars &lt;- list(
  K = K.mu,
  Linf = Linf.mu,
  t0 = t0,
  C = C,
  ts = ts,
  t_anchor = weighted.mean(date2yeardec(as.Date(paste(&ldquo;2015&rdquo;,which(repro_wt != 0),&ldquo;15&rdquo;,sep=&ldquo;-&rdquo;))) %% 1,
              w = repro_wt[which(repro_wt != 0)]),  ## weighted mean of t_anchor
  phiprime = phiprime.mu,
  tmaxrecr = tmaxrecr
)</p>

<pre><code>## fisheries dependent information
## if fisheries are simulated
if(any(!is.na(fished_t) &amp; !is.nan(fished_t))){
    res$fisheries &lt;- list(
        fished_years = yeardec2date( date2yeardec(timemin.date) + (timeseq - timemin) )[fished_t],
        E = Emat,
        q = qmat,
        F = harvest_rate
    )
}
</code></pre>

<p>if(plot){
  layout(matrix(c(1,2,3,4,5,6,7,7), ncol=2, byrow=TRUE), heights=c(4,4,4,1))
  par(mar=c(3,4,3,2))
  ## Numbers
  with(res$pop, plot(dates, N, type=&#39;l&#39;, lwd=2, 
                     xlab=&ldquo;&rdquo;,ylab=&ldquo;Numbers&rdquo;,
                     main = &ldquo;Population trajectory&rdquo;,
                     ylim=c(0,max(resf0$pop$N,na.rm=TRUE))))
  with(resf0$pop, lines(dates, N, col=&#39;dodgerblue2&#39;, lwd=2))
  points(res$pop$dates[1], N0,pch=4, lwd=2, col=&#39;darkred&#39;)
  ## Biomass  + SSB
  with(res$pop, plot(dates, B, type=&#39;l&#39;, lwd=2, 
                     xlab=&ldquo;&rdquo;,ylab=&ldquo;Biomass&rdquo;,
                     main = &ldquo;Biomass trajectory&rdquo;,
                     ylim=c(0,max(resf0$pop$B,na.rm=TRUE))))
  with(res$pop, lines(dates, SSB, lwd=2, lty=3))
  with(resf0$pop, lines(dates, B, col=&#39;dodgerblue2&#39;, lwd=2))
  with(resf0$pop, lines(dates, SSB, col=&#39;dodgerblue2&#39;, lwd=2, lty=3))
  abline(h = resf0$pop$K, col=&#39;darkred&#39;, lwd=2)
  abline(h = resf0$pop$SSBf0, col=&#39;darkred&#39;, lwd=2,lty=3)
  ## SPM
  with(resf0$pop, plot(dates, B, type=&#39;b&#39;, lwd=2,
                     xlab=&ldquo;&rdquo;,ylab=&ldquo;Biomass&rdquo;,col=&#39;dodgerblue2&#39;,
                     pch=16,
                     main = &ldquo;Surplus production model&rdquo;,
                     ylim=c(0,max(resf0$pop$B,na.rm=TRUE))))
  abline(h = resf0$pop$K2,lwd=2, lty=3, col = &#39;darkred&#39;)
  with(resf0$pop, lines(dates, bioPlot, lwd=2, lty=1, col = &#39;darkred&#39;))
  ## Production curve
  plot(bioPlot, Prod, type=&#39;l&#39;, lwd=2, col = &#39;dodgerblue2&#39;, 
       main = &ldquo;Production curve&rdquo;,
       xlab=&ldquo;Biomass&rdquo;,ylab=&ldquo;Surplus production&rdquo;, ylim = c(0,max(Prod,na.rm=TRUE)*1.1))
  segments(x0 = 0, y0 = msyd, x1 = Bdmsy, y1 = msyd, col = &ldquo;darkred&rdquo;, lty=3, lwd=2)
  segments(x0 = Bdmsy, y0 = 0, x1 = Bdmsy, y1 = msyd, col = &ldquo;darkred&rdquo;, lty=3, lwd=2)</p>

<p>## growth curve
  Lplot &lt;- seq(0,Linf.mu+10,0.1)
  suppressWarnings(agePlot &lt;- TropFishR::VBGF(res$growthpars[1:5], L = Lplot))
  ages &lt;- unlist(lapply(indsSamp, function(x) x[[&ldquo;A&rdquo;]]))
  lengths &lt;- unlist(lapply(indsSamp, function(x) x[[&ldquo;L&rdquo;]]))
  plot(ages, lengths, pch=16, 
       ylim=c(0,Linf.mu+30),
       main = &ldquo;VBGF&rdquo;,col=&#39;dodgerblue2&#39;,
       ylab=&ldquo;Length&rdquo;, xlab = &ldquo;Age&rdquo;)
  lines(agePlot, Lplot, col=&#39;darkred&#39;,lwd=2)</p>

<p>## Stock recruitment relationship
  SSBplot &lt;- seq(0,100,0.1)
  n_recruits &lt;- srrBH(rmaxBH,betaBH,SSBplot)
  n_recruits &lt;- n_recruits * rlnorm(length(n_recruits),0, sdlog = srr.cv)
  plot(SSBplot, n_recruits, type = &ldquo;l&rdquo;,
       xlab=&ldquo;SSB&rdquo;, ylab =&ldquo;Recruits&rdquo;,
       main = &ldquo;Stock recruitment relationship&rdquo;,
       lwd=2, col=&#39;dodgerblue2&#39;,ylim = c(0,max(n_recruits)*1.2))</p>

<p>## Legend
  par(mar=c(0,0,0,0))
  plot.new()
  legend(&ldquo;center&rdquo;, legend=c(&ldquo;fishing&rdquo;, &ldquo;no fishing&rdquo;, &ldquo;Reference levels&rdquo;),
         ncol = 3,
        col=c(&ldquo;black&rdquo;,&#39;dodgerblue2&#39;, &ldquo;darkred&rdquo;), lwd=2, lty=1, bty=&#39;n&#39;, 
        x.intersp = 0.4, seg.len = 0.5,cex=1.1)</p>

<p>on.exit(par(mfrow=c(1,1), mar=c(5,4,4,2)))
}</p>

<p>return(res)</p>

<p>} # end of function</p>

</body>

</html>

